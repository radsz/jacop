predicate jacop_alldiff(array [int] of var int: x);
predicate jacop_among(array [int] of var int: x, set of int: v, var int: n);
predicate jacop_among_var(array [int] of var int: x, array [int] of var int: v, var int: n);
predicate jacop_assignment(array [int] of var int: f, array [int] of var int: invf, int: index_f, int: index_invf);
predicate jacop_bin_packing(array [int] of var int: bin, array [int] of var int: cap, array [int] of int: w);
predicate jacop_circuit(array [int] of var int: x);
predicate jacop_count(array [int] of var int: x, int: y, var int: c);
predicate jacop_cumulative(array [int] of var int: s, array [int] of var int: d, array [int] of var int: r, var int: b);
predicate jacop_diff2(array [int, int] of var int: r);
predicate jacop_disjoint(var set of int: s1, var set of int: s2);
predicate jacop_gcc(array [int] of var int: x, array [int] of var int: c, int: index);
predicate jacop_global_cardinality_closed(array [int] of var int: x, array [int] of int: cover, array [int] of var int: counts);
predicate jacop_global_cardinality_low_up_closed(array [int] of var int: x, array [int] of int: cover, array [int] of int: lbound, array [int] of int: ubound);
predicate jacop_lex_less_bool(array [int] of var bool: x, array [int] of var bool: y);
predicate jacop_lex_less_int(array [int] of var int: x, array [int] of var int: y);
predicate jacop_lex_lesseq_bool(array [int] of var bool: x, array [int] of var bool: y);
predicate jacop_lex_lesseq_int(array [int] of var int: x, array [int] of var int: y);
predicate jacop_list_diff2(array [int] of var int: x, array [int] of var int: y, array [int] of var int: lx, array [int] of var int: ly);
predicate jacop_maximum(var int: m, array [int] of var int: x);
predicate jacop_minimum(var int: m, array [int] of var int: x);
predicate jacop_nvalue(var int: n, array [int] of var int: x);
predicate jacop_regular(array [int] of var int: x, int: Q, int: S, array [int, int] of int: d, int: q0, set of int: F, int: min_index);
predicate jacop_table_bool(array [int] of var bool: x, array [int, int] of bool: t);
predicate jacop_table_int(array [int] of var int: x, array [int, int] of int: t);
array [1..5] of int: c = [1, 1, 1, 1, 1];
array [1..9] of int: d = [2, 4, 1, 3, 3, 2, 5, 7, 7];
array [1..45] of int: ia = [1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0];
array [1..9] of int: ones = [1, 1, 1, 1, 1, 1, 1, 1, 1];
array [1..5] of set of int: s = [{1, 2, 4, 6, 7, 9}, {1, 2, 4, 5, 6, 8}, {1, 2, 7, 8}, {1, 5, 6, 9}, {3, 5, 6, 7, 8}];
var -264..76: INT____00001 :: is_defined_var :: var_is_introduced;
var 2..36: INT____00002 :: is_defined_var :: var_is_introduced;
var 4..38: INT____00003 :: is_defined_var :: var_is_introduced;
var 3..37: INT____00004 :: is_defined_var :: var_is_introduced;
var 2..36: INT____00005 :: is_defined_var :: var_is_introduced;
var 5..39: INT____00006 :: is_defined_var :: var_is_introduced;
var 7..41: INT____00007 :: is_defined_var :: var_is_introduced;
var 3..37: INT____00008 :: is_defined_var :: var_is_introduced;
var 7..41: INT____00009 :: is_defined_var :: var_is_introduced;
var 1..35: INT____00010 :: is_defined_var :: var_is_introduced;
var -264..76: cost :: output_var = INT____00001;
array [1..5] of var 0..34: finish :: output_array([1..5]);
array [1..9] of var 0..34: sch;
array [1..5] of var 0..34: start :: output_array([1..5]);
constraint int_lin_eq([-1, 1], [INT____00002, sch[1]], -2) :: defines_var(INT____00002);
constraint int_lin_eq([-1, 1], [INT____00003, sch[2]], -4) :: defines_var(INT____00003);
constraint int_lin_eq([-1, 1], [INT____00004, sch[4]], -3) :: defines_var(INT____00004);
constraint int_lin_eq([-1, 1], [INT____00005, sch[6]], -2) :: defines_var(INT____00005);
constraint int_lin_eq([-1, 1], [INT____00006, sch[7]], -5) :: defines_var(INT____00006);
constraint int_lin_eq([-1, 1], [INT____00007, sch[9]], -7) :: defines_var(INT____00007);
constraint int_lin_eq([-1, 1], [INT____00008, sch[5]], -3) :: defines_var(INT____00008);
constraint int_lin_eq([-1, 1], [INT____00009, sch[8]], -7) :: defines_var(INT____00009);
constraint int_lin_eq([-1, 1], [INT____00010, sch[3]], -1) :: defines_var(INT____00010);
constraint int_lin_eq([-1, 1, 1, 1, 1, 1, -1, -1, -1, -1, -1], [INT____00001, finish[1], finish[2], finish[3], finish[4], finish[5], start[1], start[2], start[3], start[4], start[5]], 94) :: defines_var(INT____00001);
constraint int_lt(sch[1], sch[5]);
constraint jacop_cumulative(sch, d, ones, 1);
constraint jacop_maximum(finish[1], [INT____00002, INT____00003, INT____00004, INT____00005, INT____00006, INT____00007]);
constraint jacop_maximum(finish[2], [INT____00002, INT____00003, INT____00004, INT____00008, INT____00005, INT____00009]);
constraint jacop_maximum(finish[3], [INT____00002, INT____00003, INT____00006, INT____00009]);
constraint jacop_maximum(finish[4], [INT____00002, INT____00008, INT____00005, INT____00007]);
constraint jacop_maximum(finish[5], [INT____00010, INT____00008, INT____00005, INT____00006, INT____00009]);
constraint jacop_minimum(start[1], [sch[1], sch[2], sch[4], sch[6], sch[7], sch[9]]);
constraint jacop_minimum(start[2], [sch[1], sch[2], sch[4], sch[5], sch[6], sch[8]]);
constraint jacop_minimum(start[3], [sch[1], sch[2], sch[7], sch[8]]);
constraint jacop_minimum(start[4], [sch[1], sch[5], sch[6], sch[9]]);
constraint jacop_minimum(start[5], [sch[3], sch[5], sch[6], sch[7], sch[8]]);
solve  :: int_search(sch, first_fail, indomain_split, complete) minimize INT____00001;
